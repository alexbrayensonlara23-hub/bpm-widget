<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Detector de BPM</title>
  <style>
    :root {
      --bg: #000;
      --fg: #fff;
      --muted: #1a1a1a;
      --accent: #fff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 24px;
      background: var(--bg); color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display: grid; place-items: center; min-height: 100vh;
    }
    .card {
      width: 100%; max-width: 720px; padding: 20px;
      border: 1px solid var(--fg); border-radius: 8px;
      background: transparent;
    }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    h1 { font-size: 20px; font-weight: 500; margin: 0 0 16px 0; }
    .controls { margin: 12px 0; display: flex; gap: 12px; flex-wrap: wrap; }
    .btn, .file, .range {
      border: 1px solid var(--fg); background: transparent; color: var(--fg);
      padding: 10px 12px; border-radius: 6px; font-size: 14px;
    }
    .btn { cursor: pointer; }
    .btn:hover { background: var(--fg); color: var(--bg); }
    .file { padding: 8px; }
    .range { width: 180px; height: 36px; padding: 0 8px; }
    .range input[type="range"] {
      -webkit-appearance: none; appearance: none;
      width: 100%; height: 4px; background: var(--fg); outline: none; border-radius: 2px;
    }
    .range input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 14px; height: 14px; border-radius: 50%; background: var(--fg);
      cursor: pointer;
    }
    .stat {
      font-size: 28px; font-weight: 600; letter-spacing: 0.5px; margin-top: 8px;
    }
    .muted { color: #bbb; font-size: 12px; }
    .bar {
      margin-top: 14px; width: 100%; height: 6px; background: var(--muted);
      border-radius: 3px; overflow: hidden;
    }
    .bar > div {
      height: 100%; width: 0%; background: var(--fg);
      transition: width 0.1s linear;
    }
    .footer { margin-top: 10px; display: flex; gap: 12px; align-items: center; justify-content: space-between; }
    .capsule { border: 1px solid var(--fg); border-radius: 999px; padding: 6px 10px; font-size: 12px; }
  </style>
</head>
<body>
  <div class="card">
    <h1>Detector de BPM</h1>

    <div class="row">
      <input class="file" id="file" type="file" accept="audio/*" />
      <button class="btn" id="analyzeBtn">Analizar BPM</button>
      <button class="btn" id="playBtn" disabled>Play</button>
      <button class="btn" id="pauseBtn" disabled>Pause</button>
      <label class="range">
        <input id="vol" type="range" min="0" max="1" step="0.01" value="0.8" />
      </label>
    </div>

    <div class="row" style="gap:24px; align-items:flex-end;">
      <div>
        <div class="muted">Resultado</div>
        <div id="bpm" class="stat">BPM: --</div>
      </div>
      <div>
        <div class="muted">Confianza</div>
        <div id="conf" class="capsule">--</div>
      </div>
      <div>
        <div class="muted">Duración</div>
        <div id="dur" class="capsule">--</div>
      </div>
    </div>

    <div class="bar" aria-label="Progreso">
      <div id="progress"></div>
    </div>

    <div class="muted" id="status" style="margin-top:10px;">Carga un archivo de audio y presiona Analizar BPM.</div>
  </div>

  <script>
    let audioCtx, gainNode, buffer = null, source = null;
    let startTime = 0, pausedAt = 0, isPlaying = false, rafId = null;

    const fileEl = document.getElementById('file');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const volEl = document.getElementById('vol');
    const bpmEl = document.getElementById('bpm');
    const confEl = document.getElementById('conf');
    const durEl = document.getElementById('dur');
    const statusEl = document.getElementById('status');
    const progressEl = document.getElementById('progress');

    initAudio();

    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.gain.value = parseFloat(volEl.value);
      gainNode.connect(audioCtx.destination);
    }

    function createSource() {
      if (!buffer) return null;
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      src.connect(gainNode);
      src.onended = () => {
        if (isPlaying) stopPlayback(false); // reached end
      };
      return src;
    }

    function updateUILoading(isLoading, message) {
      statusEl.textContent = message || (isLoading ? 'Procesando...' : '');
      analyzeBtn.disabled = isLoading;
      playBtn.disabled = !buffer;
      pauseBtn.disabled = !isPlaying;
    }

    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m}:${s.toString().padStart(2,'0')}`;
    }

    function startProgressLoop() {
      cancelAnimationFrame(rafId);
      const loop = () => {
        if (!buffer) return;
        const now = isPlaying ? (pausedAt + (audioCtx.currentTime - startTime)) : pausedAt;
        const ratio = Math.min(1, now / buffer.duration);
        progressEl.style.width = `${ratio * 100}%`;
        rafId = requestAnimationFrame(loop);
      };
      rafId = requestAnimationFrame(loop);
    }

    async function loadFileToBuffer(file) {
      const arrayBuffer = await file.arrayBuffer();
      // decodeAudioData returns a Promise in modern browsers
      return await audioCtx.decodeAudioData(arrayBuffer);
    }

    function stopPlayback(resetPosition = true) {
      try { source && source.stop(0); } catch(e) {}
      source = null;
      isPlaying = false;
      if (resetPosition) pausedAt = 0;
      pauseBtn.disabled = true;
      playBtn.disabled = !buffer;
    }

    function play() {
      if (!buffer) return;
      if (isPlaying) return;

      source = createSource();
      if (!source) return;
      startTime = audioCtx.currentTime;
      source.start(0, pausedAt);
      isPlaying = true;
      playBtn.disabled = true;
      pauseBtn.disabled = false;
      startProgressLoop();
    }

    function pause() {
      if (!buffer || !isPlaying) return;
      pausedAt += (audioCtx.currentTime - startTime);
      stopPlayback(false); // keep position
      startProgressLoop();
    }

    volEl.addEventListener('input', () => {
      gainNode.gain.value = parseFloat(volEl.value);
    });

    playBtn.addEventListener('click', () => {
      audioCtx.resume();
      play();
    });

    pauseBtn.addEventListener('click', () => {
      pause();
    });

    analyzeBtn.addEventListener('click', async () => {
      const file = fileEl.files && fileEl.files[0];
      if (!file) {
        alert('Selecciona un archivo de audio.');
        return;
      }
      stopPlayback(true);
      updateUILoading(true, 'Analizando BPM...');
      try {
        buffer = await loadFileToBuffer(file);
        durEl.textContent = formatTime(buffer.duration);
        const { bpm, confidence } = estimateBPM(buffer, { bpmMin: 60, bpmMax: 200 });
        bpmEl.textContent = Number.isFinite(bpm) ? `BPM: ${Math.round(bpm)}` : 'BPM: No detectado';
        confEl.textContent = Number.isFinite(confidence) ? `${Math.round(confidence * 100)}%` : '--';
        statusEl.textContent = Number.isFinite(bpm) ? 'Análisis completado.' : 'No se pudo estimar el BPM. Prueba con otro fragmento o mayor volumen de transientes.';
        playBtn.disabled = !buffer;
        pausedAt = 0;
        progressEl.style.width = '0%';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Error al procesar el audio.';
        bpmEl.textContent = 'BPM: --';
        confEl.textContent = '--';
      } finally {
        analyzeBtn.disabled = false;
      }
    });

    // Estimación robusta de BPM con autocorrelación de la envolvente de onsets
    function estimateBPM(buf, { bpmMin = 60, bpmMax = 200 } = {}) {
      const sr = buf.sampleRate;
      const channels = buf.numberOfChannels;
      // Mezcla a mono
      const length = buf.length;
      const mono = new Float32Array(length);
      for (let ch = 0; ch < channels; ch++) {
        const data = buf.getChannelData(ch);
        for (let i = 0; i < length; i++) mono[i] += data[i] / channels;
      }

      // Downsample simple por decimación a ~11025 Hz
      const targetSr = 11025;
      const decim = Math.max(1, Math.floor(sr / targetSr));
      const dsLen = Math.floor(length / decim);
      const ds = new Float32Array(dsLen);
      for (let i = 0, j = 0; i < dsLen; i++, j += decim) ds[i] = mono[j];

      // Envoltura de onsets: energía por frames + diferencia positiva
      const frameSize = 1024;
      const hopSize = 512;
      const nFrames = Math.max(0, Math.floor((ds.length - frameSize) / hopSize));
      if (nFrames < 4) return { bpm: NaN, confidence: NaN };

      const energy = new Float32Array(nFrames);
      for (let f = 0; f < nFrames; f++) {
        const start = f * hopSize;
        let sum = 0;
        for (let k = 0; k < frameSize; k++) {
          const v = ds[start + k];
          sum += v * v;
        }
        energy[f] = sum;
      }

      // Diferencia positiva
      const onset = new Float32Array(nFrames);
      let maxOn = 0;
      for (let f = 1; f < nFrames; f++) {
        const diff = energy[f] - energy[f - 1];
        const val = diff > 0 ? diff : 0;
        onset[f] = val;
        if (val > maxOn) maxOn = val;
      }
      // Normaliza
      if (maxOn > 0) {
        for (let f = 0; f < nFrames; f++) onset[f] /= maxOn;
      }

      // Autocorrelación en rango de BPM objetivo
      const framesPerSecond = (targetSr) / hopSize;
      const lagMin = Math.max(2, Math.floor(framesPerSecond * 60 / bpmMax));
      const lagMax = Math.min(nFrames - 2, Math.floor(framesPerSecond * 60 / bpmMin));
      if (lagMax <= lagMin) return { bpm: NaN, confidence: NaN };

      const ac = new Float32Array(lagMax + 1);
      for (let lag = lagMin; lag <= lagMax; lag++) {
        let sum = 0;
        const limit = nFrames - lag;
        for (let n = 0; n < limit; n++) sum += onset[n] * onset[n + lag];
        ac[lag] = sum / limit;
      }

      // Encuentra pico principal
      let bestLag = lagMin, bestVal = -Infinity;
      for (let lag = lagMin; lag <= lagMax; lag++) {
        if (ac[lag] > bestVal) { bestVal = ac[lag]; bestLag = lag; }
      }

      // Interpolación parabólica simple para refinar
      let refinedLag = bestLag;
      if (bestLag > lagMin && bestLag < lagMax) {
        const y1 = ac[bestLag - 1], y2 = ac[bestLag], y3 = ac[bestLag + 1];
        const denom = (y1 - 2 * y2 + y3);
        if (Math.abs(denom) > 1e-9) {
          const delta = 0.5 * (y1 - y3) / denom;
          refinedLag = bestLag + Math.max(-1, Math.min(1, delta));
        }
      }

      // Candidatos armónicos (x0.5, x1, x2) y selección por correlación
      const candidates = [];
      const tryLag = (L) => {
        if (L >= lagMin && L <= lagMax) candidates.push({ lag: L, val: ac[Math.round(L)] });
      };
      tryLag(refinedLag);
      tryLag(refinedLag * 0.5);
      tryLag(refinedLag * 2);
      candidates.sort((a,b) => b.val - a.val);
      const chosen = candidates[0] || { lag: refinedLag, val: ac[Math.round(refinedLag)] };

      let bpm = 60 * framesPerSecond / chosen.lag;
      // Normaliza a rango 60-200 BPM
      while (bpm < 60) bpm *= 2;
      while (bpm > 200) bpm /= 2;

      // Confianza: pico / mediana del AC
      const vals = [];
      for (let lag = lagMin; lag <= lagMax; lag++) vals.push(ac[lag]);
      vals.sort((a,b)=>a-b);
      const mid = Math.floor(vals.length/2);
      const median = vals.length % 2 ? vals[mid] : 0.5*(vals[mid-1]+vals[mid]);
      const confidence = (median > 1e-9) ? Math.max(0, Math.min(1, chosen.val / (median * 4))) : 0.0;

      return { bpm, confidence };
    }
  </script>
</body>
</html>
